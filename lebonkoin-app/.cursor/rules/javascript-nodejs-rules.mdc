# üöÄ JAVASCRIPT & NODE.JS - BACKEND LEBONKOIN

## üéØ R√àGLES JAVASCRIPT OBLIGATOIRES

### ‚úÖ Structure et Imports Standard
```javascript
// OBLIGATOIRE : Imports des 3 technologies en ES6
import { WorldIDWidget, verifyCloudProof } from '@worldcoin/idkit';
import { CCTPSDKv2 } from '@circle-fin/cctp-sdk';
import { ethers } from 'ethers';
import express from 'express';
import cors from 'cors';
import helmet from 'helmet';
import rateLimit from 'express-rate-limit';

// OBLIGATOIRE : Configuration environnement
const config = {
  // World ID
  WORLD_APP_ID: process.env.WORLD_APP_ID,
  WORLD_API_KEY: process.env.WORLD_API_KEY,
  
  // Circle CCTP V2
  CIRCLE_API_KEY: process.env.CIRCLE_API_KEY,
  CCTP_ENVIRONMENT: process.env.NODE_ENV === 'production' ? 'mainnet' : 'testnet',
  
  // Blockchain
  ETHEREUM_RPC: process.env.ETHEREUM_RPC,
  BASE_RPC: process.env.BASE_RPC,
  ARBITRUM_RPC: process.env.ARBITRUM_RPC,
  
  // LeBonKoin
  ESCROW_CONTRACT_ADDRESS: process.env.ESCROW_CONTRACT_ADDRESS,
  MONGODB_URI: process.env.MONGODB_URI,
  JWT_SECRET: process.env.JWT_SECRET
};

// OBLIGATOIRE : Validation de la configuration
const validateConfig = () => {
  const requiredVars = [
    'WORLD_APP_ID', 'CIRCLE_API_KEY', 'ETHEREUM_RPC', 
    'ESCROW_CONTRACT_ADDRESS', 'MONGODB_URI', 'JWT_SECRET'
  ];
  
  for (const varName of requiredVars) {
    if (!config[varName]) {
      throw new Error(`Variable d'environnement manquante: ${varName}`);
    }
  }
};
```

### üîß Services Obligatoires
```javascript
// OBLIGATOIRE : Service World ID
class WorldIDService {
  constructor() {
    this.appId = config.WORLD_APP_ID;
    this.apiKey = config.WORLD_API_KEY;
  }
  
  /**
   * V√©rifier un proof World ID
   * @param {Object} proof - Proof World ID
   * @param {string} action - Action √† v√©rifier
   * @param {string} signal - Signal de l'action
   * @returns {Promise<Object>} R√©sultat de v√©rification
   */
  async verifyProof(proof, action, signal) {
    try {
      const verifyRes = await verifyCloudProof(
        proof, 
        this.appId, 
        action, 
        signal
      );
      
      if (verifyRes.success) {
        return {
          success: true,
          worldId: proof.nullifier_hash,
          verified: true
        };
      } else {
        throw new Error('V√©rification World ID √©chou√©e');
      }
    } catch (error) {
      console.error('Erreur World ID:', error);
      return {
        success: false,
        error: error.message
      };
    }
  }
  
  /**
   * V√©rifier l'unicit√© d'une action
   * @param {string} worldId - World ID de l'utilisateur
   * @param {string} action - Action √† v√©rifier
   * @returns {Promise<boolean>} True si l'action est unique
   */
  async checkActionUniqueness(worldId, action) {
    // V√©rifier en base de donn√©es que l'action n'a pas d√©j√† √©t√© effectu√©e
    const existingAction = await db.collection('world_actions').findOne({
      worldId,
      action,
      createdAt: { $gte: new Date(Date.now() - 24 * 60 * 60 * 1000) } // 24h
    });
    
    return !existingAction;
  }
}

// OBLIGATOIRE : Service CCTP V2
class CCTPService {
  constructor() {
    this.sdk = new CCTPSDKv2({
      environment: config.CCTP_ENVIRONMENT,
      apiKey: config.CIRCLE_API_KEY
    });
    
    this.supportedChains = [
      'ethereum', 'base', 'arbitrum', 'avalanche', 'linea', 'sonic'
    ];
  }
  
  /**
   * Cr√©er un Fast Transfer CCTP V2
   * @param {Object} transferData - Donn√©es du transfert
   * @returns {Promise<string>} Transaction ID
   */
  async createFastTransfer(transferData) {
    try {
      const { 
        amount, 
        sourceChain, 
        destinationChain, 
        recipient, 
        listingId,
        buyerId,
        sellerId 
      } = transferData;
      
      // Validation des cha√Ænes support√©es
      if (!this.supportedChains.includes(sourceChain)) {
        throw new Error(`Cha√Æne source non support√©e: ${sourceChain}`);
      }
      
      if (!this.supportedChains.includes(destinationChain)) {
        throw new Error(`Cha√Æne destination non support√©e: ${destinationChain}`);
      }
      
      // Cr√©er le transfert rapide
      const transfer = await this.sdk.createFastTransfer({
        amount: amount.toString(),
        sourceChain,
        destinationChain,
        recipient,
        metadata: {
          listingId,
          buyerId,
          sellerId,
          platform: 'lebonkoin'
        }
      });
      
      // Sauvegarder en base
      await this.saveTransfer({
        ...transferData,
        transactionId: transfer.transactionId,
        status: 'pending',
        createdAt: new Date()
      });
      
      return transfer.transactionId;
    } catch (error) {
      console.error('Erreur CCTP Fast Transfer:', error);
      throw new Error(`Impossible de cr√©er le transfert: ${error.message}`);
    }
  }
  
  /**
   * Surveiller le statut d'un transfert
   * @param {string} transactionId - ID de la transaction
   * @returns {Promise<Object>} Statut du transfert
   */
  async monitorTransfer(transactionId) {
    try {
      const status = await this.sdk.getTransferStatus(transactionId);
      
      // Mettre √† jour en base
      await db.collection('cctp_transfers').updateOne(
        { transactionId },
        { 
          $set: { 
            status: status.status,
            updatedAt: new Date()
          }
        }
      );
      
      return status;
    } catch (error) {
      console.error('Erreur monitoring CCTP:', error);
      throw error;
    }
  }
  
  async saveTransfer(transferData) {
    await db.collection('cctp_transfers').insertOne(transferData);
  }
}

// OBLIGATOIRE : Service ERC-7730
class ERC7730Service {
  constructor() {
    this.providers = {
      ethereum: new ethers.providers.JsonRpcProvider(config.ETHEREUM_RPC),
      base: new ethers.providers.JsonRpcProvider(config.BASE_RPC),
      arbitrum: new ethers.providers.JsonRpcProvider(config.ARBITRUM_RPC)
    };
  }
  
  /**
   * Valider une transaction pour ERC-7730
   * @param {Object} transaction - Transaction √† valider
   * @returns {Promise<Object>} R√©sultat de validation
   */
  async validateTransaction(transaction) {
    try {
      const { to, data, chainId } = transaction;
      
      // Obtenir le provider appropri√©
      const provider = this.getProviderByChainId(chainId);
      if (!provider) {
        throw new Error(`Cha√Æne non support√©e: ${chainId}`);
      }
      
      // D√©coder les donn√©es de transaction
      const functionSelector = data.slice(0, 10);
      
      // V√©rifier si un descripteur ERC-7730 existe
      const contract = new ethers.Contract(to, ['function getTransactionMetadata(bytes4) view returns (string)'], provider);
      
      try {
        const metadata = await contract.getTransactionMetadata(functionSelector);
        
        return {
          isValid: true,
          metadata: JSON.parse(metadata),
          displayText: this.generateDisplayText(metadata, transaction)
        };
      } catch (error) {
        // Pas de descripteur ERC-7730 disponible
        return {
          isValid: false,
          error: 'Aucun descripteur ERC-7730 trouv√©'
        };
      }
    } catch (error) {
      console.error('Erreur validation ERC-7730:', error);
      return {
        isValid: false,
        error: error.message
      };
    }
  }
  
  /**
   * G√©n√©rer le texte d'affichage pour une transaction
   * @param {string} metadata - M√©tadonn√©es ERC-7730
   * @param {Object} transaction - Transaction
   * @returns {string} Texte d'affichage
   */
  generateDisplayText(metadata, transaction) {
    try {
      const meta = JSON.parse(metadata);
      let displayText = meta.intent || 'Transaction LeBonKoin';
      
      // Remplacer les variables dans le texte
      if (meta.fields && transaction.decodedParams) {
        meta.fields.forEach(field => {
          const value = transaction.decodedParams[field];
          if (value) {
            displayText = displayText.replace(`{{${field}}}`, value);
          }
        });
      }
      
      return displayText;
    } catch (error) {
      return 'Transaction LeBonKoin';
    }
  }
  
  getProviderByChainId(chainId) {
    const chainMap = {
      1: 'ethereum',
      8453: 'base',
      42161: 'arbitrum'
    };
    
    return this.providers[chainMap[chainId]];
  }
}
```

## üåê API EXPRESS OBLIGATOIRE

### Configuration Serveur
```javascript
// OBLIGATOIRE : Configuration Express avec s√©curit√©
const app = express();

// Middleware de s√©curit√© obligatoires
app.use(helmet());
app.use(cors({
  origin: process.env.FRONTEND_URL || 'http://localhost:3000',
  credentials: true
}));

// Rate limiting obligatoire
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // 100 requ√™tes par IP
  message: 'Trop de requ√™tes, veuillez r√©essayer plus tard'
});
app.use(limiter);

// Middleware de parsing
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true }));

// Middleware de logging
app.use((req, res, next) => {
  console.log(`${new Date().toISOString()} - ${req.method} ${req.path}`);
  next();
});
```

### Routes API Obligatoires
```javascript
// OBLIGATOIRE : Routes World ID
app.post('/api/auth/verify-world-id', async (req, res) => {
  try {
    const { proof, action, signal } = req.body;
    
    // Validation des donn√©es
    if (!proof || !action) {
      return res.status(400).json({
        success: false,
        error: 'Proof et action requis'
      });
    }
    
    const worldIdService = new WorldIDService();
    const result = await worldIdService.verifyProof(proof, action, signal);
    
    if (result.success) {
      // Cr√©er ou mettre √† jour l'utilisateur
      const user = await createOrUpdateUser({
        worldId: result.worldId,
        isVerified: true,
        lastVerification: new Date()
      });
      
      // G√©n√©rer JWT
      const token = jwt.sign(
        { worldId: result.worldId, userId: user._id },
        config.JWT_SECRET,
        { expiresIn: '24h' }
      );
      
      res.json({
        success: true,
        user,
        token
      });
    } else {
      res.status(401).json(result);
    }
  } catch (error) {
    console.error('Erreur v√©rification World ID:', error);
    res.status(500).json({
      success: false,
      error: 'Erreur serveur'
    });
  }
});

// OBLIGATOIRE : Routes CCTP V2
app.post('/api/payments/create-fast-transfer', authenticateWorldID, async (req, res) => {
  try {
    const { 
      listingId, 
      amount, 
      sourceChain, 
      destinationChain,
      sellerId 
    } = req.body;
    
    // Validation des donn√©es
    const validation = validatePaymentData(req.body);
    if (!validation.isValid) {
      return res.status(400).json({
        success: false,
        error: validation.error
      });
    }
    
    const cctpService = new CCTPService();
    const transactionId = await cctpService.createFastTransfer({
      listingId,
      amount,
      sourceChain,
      destinationChain,
      recipient: config.ESCROW_CONTRACT_ADDRESS,
      buyerId: req.user.worldId,
      sellerId
    });
    
    res.json({
      success: true,
      transactionId,
      estimatedTime: '8-20 secondes'
    });
  } catch (error) {
    console.error('Erreur cr√©ation Fast Transfer:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

app.get('/api/payments/status/:transactionId', authenticateWorldID, async (req, res) => {
  try {
    const { transactionId } = req.params;
    
    const cctpService = new CCTPService();
    const status = await cctpService.monitorTransfer(transactionId);
    
    res.json({
      success: true,
      status
    });
  } catch (error) {
    console.error('Erreur statut transfert:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// OBLIGATOIRE : Routes ERC-7730
app.post('/api/transactions/validate-erc7730', authenticateWorldID, async (req, res) => {
  try {
    const { transaction } = req.body;
    
    if (!transaction || !transaction.to || !transaction.data) {
      return res.status(400).json({
        success: false,
        error: 'Donn√©es de transaction invalides'
      });
    }
    
    const erc7730Service = new ERC7730Service();
    const validation = await erc7730Service.validateTransaction(transaction);
    
    res.json({
      success: true,
      validation
    });
  } catch (error) {
    console.error('Erreur validation ERC-7730:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});
```

### Middleware d'Authentification
```javascript
// OBLIGATOIRE : Middleware World ID
const authenticateWorldID = async (req, res, next) => {
  try {
    const token = req.headers.authorization?.replace('Bearer ', '');
    
    if (!token) {
      return res.status(401).json({
        success: false,
        error: 'Token d\'authentification requis'
      });
    }
    
    const decoded = jwt.verify(token, config.JWT_SECRET);
    
    // V√©rifier que l'utilisateur existe et est v√©rifi√©
    const user = await db.collection('users').findOne({
      worldId: decoded.worldId,
      isVerified: true
    });
    
    if (!user) {
      return res.status(401).json({
        success: false,
        error: 'Utilisateur non v√©rifi√©'
      });
    }
    
    req.user = user;
    next();
  } catch (error) {
    return res.status(401).json({
      success: false,
      error: 'Token invalide'
    });
  }
};
```

## üóÑÔ∏è BASE DE DONN√âES MONGODB

### Sch√©mas de Donn√©es
```javascript
// OBLIGATOIRE : Sch√©ma utilisateur
const userSchema = {
  worldId: { type: String, required: true, unique: true },
  isVerified: { type: Boolean, default: false },
  reputation: { type: Number, default: 0 },
  preferredChains: [String],
  escrowTransactions: [String],
  createdAt: { type: Date, default: Date.now },
  lastVerification: Date,
  profile: {
    isAnonymous: { type: Boolean, default: true },
    canSell: { type: Boolean, default: true },
    canBuy: { type: Boolean, default: true },
    maxTransactionAmount: { type: String, default: '1000' }
  }
};

// OBLIGATOIRE : Sch√©ma annonce
const listingSchema = {
  id: { type: String, required: true, unique: true },
  title: { type: String, required: true },
  description: { type: String, required: true },
  price: { type: String, required: true }, // USDC
  images: [String],
  category: { type: String, required: true },
  location: String,
  sellerId: { type: String, required: true }, // World ID
  acceptedChains: [String],
  status: { 
    type: String, 
    enum: ['active', 'sold', 'reserved'], 
    default: 'active' 
  },
  requiresClearSigning: { type: Boolean, default: true },
  escrowAddress: String,
  createdAt: { type: Date, default: Date.now }
};

// OBLIGATOIRE : Sch√©ma transfert CCTP
const cctpTransferSchema = {
  transactionId: { type: String, required: true, unique: true },
  listingId: { type: String, required: true },
  buyerId: { type: String, required: true }, // World ID
  sellerId: { type: String, required: true }, // World ID
  amount: { type: String, required: true },
  sourceChain: { type: String, required: true },
  destinationChain: { type: String, required: true },
  status: { 
    type: String, 
    enum: ['pending', 'completed', 'failed'], 
    default: 'pending' 
  },
  cctpMessageHash: String,
  createdAt: { type: Date, default: Date.now },
  completedAt: Date
};
```

## üö® GESTION D'ERREURS

### Handler d'Erreurs Global
```javascript
// OBLIGATOIRE : Gestion d'erreurs centralis√©e
class LeBonKoinError extends Error {
  constructor(message, type, statusCode = 500) {
    super(message);
    this.type = type;
    this.statusCode = statusCode;
  }
}

// Types d'erreurs sp√©cifiques
const ErrorTypes = {
  WORLD_ID_ERROR: 'WORLD_ID_ERROR',
  CCTP_ERROR: 'CCTP_ERROR',
  ERC7730_ERROR: 'ERC7730_ERROR',
  VALIDATION_ERROR: 'VALIDATION_ERROR',
  DATABASE_ERROR: 'DATABASE_ERROR'
};

// Middleware de gestion d'erreurs
app.use((error, req, res, next) => {
  console.error('Erreur:', error);
  
  if (error instanceof LeBonKoinError) {
    return res.status(error.statusCode).json({
      success: false,
      error: error.message,
      type: error.type
    });
  }
  
  // Erreur g√©n√©rique
  res.status(500).json({
    success: false,
    error: 'Erreur serveur interne',
    type: 'SERVER_ERROR'
  });
});
```

---

**üéØ R√àGLES ABSOLUES JAVASCRIPT** :
- ‚úÖ **ES6+** obligatoire avec imports/exports
- ‚úÖ **World ID** v√©rifi√© pour toutes les routes sensibles
- ‚úÖ **CCTP V2** pour tous les paiements
- ‚úÖ **ERC-7730** validation pour toutes les transactions
- ‚úÖ **Express** avec middleware de s√©curit√©
- ‚úÖ **MongoDB** avec sch√©mas valid√©s
- ‚úÖ **JWT** pour l'authentification
- ‚úÖ **Gestion d'erreurs** centralis√©e et typ√©e
